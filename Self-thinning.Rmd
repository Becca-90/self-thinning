---
title: "Self-thinning"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk




## Self-thinning -- background info
Obtaining the Self-Thinning Line from a size structured non-finite population growing through time


1. The "self-thinning line" is obtained when we plot N, the number of individuals of each size bracket per unit area (size structured density), against mean S, their mean size (e.g. via their "height"). Scaling these axes by log10 produces a straight "thinning line".

$$ N_{T}= \int_{S_{0}}^{S_{MAX}}N(S)ds.....S_{T} = \int_{S_{0}}^{S_{MAX}} S.N(S)ds.....\overline{S} = \frac{S_{T}}{N_{T}} $$
i.e. the plot shows size-density (N-S) using the above integrals to calculate N and S across the size spectrum. 

a. To get the total N, we integrate N from initial to max size to get the total number of individuals, for all steps through time. I.e. calculating the area under the curve from S_0 to S_MAX at time step 1, then the area under the curve from S_0 to S_MAX at time step 2, etc → i.e. integrating: S*N(S), the size x the # of individuals at that size: from initial to max size, and mean size is just the total quantity of size e.g. combined heights / number at that height (N(T))

b. For total S, we integrate 

c. We need the mean size $\overline S$ for our self-thinning line, which we can get by dividing the combined size by total density at each step

2a. We cannot simply use the "density" output from plant, which represents the cohorts or the expected/average individual trajectories of specific size/age classes with varying numbers over time. We must use the size/age data of all individual plants for the self-thinning dynamic to be observed. The integration must be weighted by the number of individuals in each size/age class. With cohorts we are just using a representative individual without the details of how many individuals each may represent, the cohort-density with size. For example if we took 100 cohorts that each represent a different approximate age/size, each representing numbers from close to zero to numerous individuals, but we simply divided the total height by 100 rather than the number those 100 cohort "groups" represent, we essentially lose all the important individual density data.

3a. We improve our approximation by integrating across the regions under the size-density curve we are interested in, accounting for the number of individuals and their mean height for each separate size class. In doing so, we are able to account for the continual influx of saplings which would otherwise skew our mean height and density data, and thus focus on the larger individuals that are growing into maturity. This can be done with the following integral and its approximate sum:

$$ \overline{H}=\int_0^\infty \frac{ Hn(H,t)}{N(t)}dt \simeq \frac{\sum H_{i}n(H_{i},t)(H_{i}-H_{i-1})}{\sum n(H_{i},t)(H_{i}-H_{i-1})} = \frac{\sum H_{i}}{K}$$
b. However, we must recognise that not all our subintervals of integration will be equal in size/width, as the time steps in the initial stand phase are much shorter to account for the extremely dynamic nature of this period and to capture all of this detail. We cannot take K to be a sum of equal (Hi - (Hi-1)) segments. And the regular introduction of new individuals at different times means that we need to determine the density per height segment (Hi-(Hi-1)) per unit area, #/H/m^2

[actually no, still need to account for weighted density] In an even-aged population where all trees are approximately the same age and growing at close to the same rate, and there are a finite number of individuals in the stand, this method might produce a reasonable approximation of the thinning line. 

c. Trapazoidal Rule in R → The Trapezoidal Rule is one of Closed Newton-Cotes formulas for approximating the definite integral of a function. We integrate by calculating and summing the areas of many consecutive trapezoids below our size-density curve, which gives a good approximation of the population dynamics in this case.

d. Additionally, we may need to select a cut-off point in the stand's age at which we stop incorporating new individuals into the model, as these new saplings likely pop up (when older larger plants die during the thinning process providing short periods of increased light and space?), but these saplings don't persist to compete with the main/mature stand. + minimum height to further reduce noise?

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, eval=FALSE}
#remotes::install_github("traitecoevo/plant", branch = "develop", force = TRUE)
```

```{r load libraries}
library(plant)
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(purrr)
source("R/grow_tidy_expand_totals function.R")
source("R/base_params function.R")
source("R/run_mypatch_edit function.R")
source("R/grow_plot function.R")
```

```{r activate logger}
plant_log_console()
```

## Self-thinnning Plot
Average size over time. Get average size by dividing total of chosen size variable by the sum of individuals per unit area - we have mean stem area, mean stem diameter, mean height, mean mass above ground, and also mean LA

## Exponential decay function to capture first wave of individiuals

```{r}
##seed_rain*exp(-decay*time) time in years --> what does the exponential decay look like?
seed_rain_decay <- function(seedrain = 100, decay = 0, time = seq(0, 10, by=0.01)){
  tibble(
    time = time,
    seeds = seedrain*exp(-decay*time)
  )
}

seed_rain_decay(100,5) %>%
  ggplot(aes(time, seeds)) +
  geom_line() 

```

## Varying mortality rate

```{r}
mort_runs <- c(0.0, 0.1) %>% set_names(.) %>% map(~grow_tidy_expand_totals(B_dI1 = .x))

mort_values <-
  mort_runs %>% map_dfr(~.x$patch_total, .id = "run")
  
mort_values %>%
  ggplot(aes(time, area_leaf, col=run)) +
  geom_line()


```


## Trait comparison: 1. LMA
```{r}

# 1. thick vs thin leaves
lma_runs <- 
    c(0.07, 0.24, 0.5) %>% set_names(.) %>% 
    map(~grow_tidy_expand_totals(traits=trait_matrix(.x, "lma")))

lma_values <-
  lma_runs %>% map_dfr(~.x$patch_total, .id = "run")

lma_values %>%
  filter(time > 0.2) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

lma_values %>%
  filter(time > 0.2, area_leaf_av > 1, area_leaf_av < 100) %>%
  ggplot(aes(area_leaf_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

```


## Trait comparison: 2. narea ...also blf1
```{r}

narea_runs <- c(0.00187, 0.003, 0.005) %>% set_names(.) %>% map(~grow_tidy_expand_totals(narea = .x))
narea_vals <- narea_runs %>% map_dfr(~.x$patch_total, .id = "run")

narea_vals %>%
  filter(time > 0.2) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

```


## Trait comparison: 3. HMAT
```{r}

hmat_runs <- c(5, 10, 25, 40) %>% set_names(.) %>% map(~grow_tidy_expand_totals(traits=trait_matrix(.x, "hmat")))
hmat_vals <-
  hmat_runs %>% map_dfr(~.x$patch_total, .id = "run")

hmat_vals %>%
  filter(time > 0.2) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

```


# 1. plot total LA and biomass over time - differences? how big?
```{r}

lma_runs <- c(0.07, 0.24, 0.5) %>% set_names(.) %>% map(~grow_tidy_expand_totals(traits=trait_matrix(.x, "lma")))
lma_values <-
  lma_runs %>% map_dfr(~.x$patch_total, .id = "run")

#LA over time
lma_values %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, area_leaf, col=run)) + 
  geom_line() +
  theme_classic()

#total mass over time
lma_values %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, mass_total, col = run)) +
  geom_line() +
  theme_classic()

#average mass over time
lma_values %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, mass_above_ground_av, col = run)) +
  geom_line() +
  theme_classic()

lma_values %>%
  filter(time > 0.2, time < 15) %>%
  ggplot(aes(time, mass_above_ground_av, col = run)) +
  geom_line() +
  theme_classic()



narea_runs <- c(0.00187, 0.003, 0.005) %>% set_names(.) %>% map(~grow_tidy_expand_totals(narea = .x))
narea_vals <- narea_runs %>% map_dfr(~.x$patch_total, .id = "run")

# LA over time
narea_vals %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, area_leaf, col=run)) + 
  geom_line() +
  theme_classic()

# total mass over time
narea_vals %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, mass_total, col = run)) +
  geom_line() +
  theme_classic()

# average mass over time
narea_vals %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, mass_av, col = run)) +
  geom_line() +
  theme_classic()


# plot size distribution
lma_vals_expand <- lma_runs %>% map_dfr(~.x$patch_expand$species, .id = "run")
plot_size_distribution(lma_vals_expand)

narea_vals_expand <- narea_runs %>% map_dfr(~.x$patch_expand$species, .id = "run")
plot_size_distribution(narea_vals_expand)

```


# 2. turn into differences in self-thinning line, zoom in and out
```{r}
# self-thinning plots
lma_values %>%
filter(time > 0.2) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

# zoom in/out
lma_values %>%
  mutate(area_leaf_av = area_leaf/individuals) %>%
filter(time > 0.2, area_leaf_av > 1, area_leaf_av < 100) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

```


# 3.a. vary two traits at once: LMA/narea
```{r}
lmas <- c(0.07, 0.24, 0.5)
nareas <- c(0.00187, 0.003, 0.005)   #x and y equal length, or one vector of length 1 will get repeated

lmas_nareas <- map2(lmas, nareas, ~grow_tidy_expand_totals(traits=trait_matrix(.x, "lma"), narea = .y), .id = "run")

lmas_nareas_totals <- lmas_hmats %>% map_dfr(~.x$patch_total, .id = "run") 
## anonymous function takes .x from before pipe and feeds into $patch_total, .x is the lmas_hmats object, map_dfr needs a function so can't just do map_dfr(lmas_hmats$patch_total)
lmas_nareas_expandsp <- lmas_hmats %>% map_dfr(~.x$patch_expand$species, .id = "run")

lmas_nareas_totals %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, area_leaf, col=run)) + 
  geom_line() +
  theme_classic()

lmas_nareas_totals %>%
  filter(time > 0.2) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

lmas_nareas_totals %>%
  filter(time > 0.2, area_stem_av > 1e-06, area_stem_av < 1e0) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()

p1 = lmas_nareas_expandsp %>% filter(run == 1) %>% plot_size_distribution()

```


# 3.b. vary 3 traits: LMA/narea/hmat
```{r}
lmas2 <- c(0.07, 0.125, 0.24, 0.5)
hmats2 <- c(5, 10, 25, 40)
nareas2 <- c(0.00187, 0.0025, 0.0035, 0.005)

tradeoffs <- list(c(0.07, 0.125, 0.24, 0.5), c(5, 10, 25, 40), c(0.00187, 0.0025, 0.0035, 0.005))
tradeoffs_runs <- pmap(tradeoffs, ~grow_tidy_expand_totals(traits=trait_matrix(..1, "lma"), trait_matrix(..2, "hmat"), narea = ..3))

tradeoffs_values <- tradeoffs_runs %>% map_dfr(~.x$patch_total, .id = "run")

tradeoffs_values %>%
  filter(time > 0.2, area_stem_av >1e-07, area_stem_av < 1e-00) %>%
  ggplot(aes(area_stem_av, individuals, col=run)) + 
  geom_line() +
  scale_x_log10() +
  scale_y_log10() +
  theme_classic()


tradeoffs_values %>%
  filter(time > 0.2) %>%
  ggplot(aes(time, area_leaf, col=run)) + 
  geom_line() +
  theme_classic()

```


## Visualise tradeoffs
```{r}

## LMA vs k_l
k_l_tradeoffs <- function(lma_0 = 0.1978791,
                lma = 0.1978791,
                B_kl1=0.4565855,
                B_kl2=1.71){
  
  k_l_val <- B_kl1 * (lma / lma_0) ^ (-B_kl2)
  k_l_df <- tibble(lma, k_l_val, B_kl2)
  return(k_l_df)
  
}

## weak & strong trade-off strength
lmall_tradeoff_low <- seq(0.07, 2.5, by=0.02) %>% set_names(.) %>% map_dfr(~k_l_tradeoffs(lma=.x, B_kl2 = 0.5))
lmall_tradeoff_high <- seq(0.07, 2.5, by=0.02) %>% set_names(.) %>% map_dfr(~k_l_tradeoffs(lma=.x, B_kl2=1.5)) 
  
ggplot() + 
  geom_line(data = lmall_tradeoff_high, aes(lma, k_l_val), colour="red") +
  geom_line(data = lmall_tradeoff_low, aes(lma, k_l_val), colour="blue") +
  theme_classic() +
  xlab("LMA kg/m^2") +
  ylab("LMA - LL trade-off")



## narea affecting Amax and respiration
amax_tradeoffs <- function(narea_0=1.87e-3, 
                 narea=1.87e-3, 
                 B_lf5=1,
                 B_lf1=0.8273474){
  
Amax <- B_lf1 * (narea/narea_0) ^ B_lf5
Amax_df <- tibble(Amax, narea, B_lf5)
return(Amax_df)

}

## weak & strong trade-off strength
amax_tradeoff_low <- seq(0.00187, 0.0031, by=0.0001) %>% set_names(.) %>% map_dfr(~amax_tradeoffs(narea=.x))
amax_tradeoff_high <- seq(0.00187, 0.0031, by=0.0001) %>% set_names(.) %>% map_dfr(~amax_tradeoffs(narea=.x, B_lf5=3))

ggplot() + 
  geom_line(data = amax_tradeoff_low, aes(narea, Amax), colour="blue") +
  geom_line(data = amax_tradeoff_high, aes(narea, Amax), colour="red") +
  theme_classic() +
  xlab("Narea [kg/m^2]") +
  ylab("Nitrogen - photsynthesis/respiration trade-off")


## wood density affecting DI mortality and wood turnover rate
wd_tradeoffs <- function(
  rho_0 = 608,
  rho = 608, 
  B_dI1 = 0.01,
  B_dI2=0.0,
  B_ks1=0.2,
  B_ks2=0.0
) {
  
  d_I <- B_dI1 * (rho / rho_0) ^ (-B_dI2)
  k_s <- B_ks1 * (rho / rho_0) ^ (-B_ks2)
  
  di_ks_df <- tibble(k_s, d_I, rho, B_ks2, B_dI2)
  
  return(di_ks_df)
  
}

## weak & strong trade-off strength
dI_weak <- seq(400, 800, by=10) %>% set_names(.) %>% map_dfr(~wd_tradeoffs(rho=.x, B_dI2=0.5))
dI_strong <- seq(400, 800, by=10) %>% set_names(.) %>% map_dfr(~wd_tradeoffs(rho=.x, B_dI2=3)) 
  
ggplot() + 
  geom_line(data = dI_weak, aes(rho, d_I), colour="blue") +
  geom_line(data = dI_strong, aes(rho, d_I), colour="red") +
  theme_classic() +
  xlab("wood density [kg/m^3]") +
  ylab("WD - DI Mortality trade-off")

ks_weak <- seq(400, 800, by=10) %>% set_names(.) %>% map_dfr(~wd_tradeoffs(rho=.x, B_ks2=0.5))
ks_strong <- seq(400, 800, by=10) %>% set_names(.) %>% map_dfr(~wd_tradeoffs(rho=.x, B_ks2=3))

ggplot() + 
  geom_line(data = ks_weak, aes(rho, k_s), colour="blue") +
  geom_line(data = ks_strong, aes(rho, k_s), colour="red") +
  theme_classic() +
  xlab("wood density [kg/m^3]") +
  ylab("WD - wood turnover rate trade-off")
```

