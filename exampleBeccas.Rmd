---
title: "self-thinning edits"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# installation
Using a version off a branch

```{r, eval=FALSE}
remotes::install_github("traitecoevo/plant", branch = "develop", force = TRUE)

```


```{r load libraries}
library(plant)
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(purrr)
```

Activate logger

```{r}
plant_log_console()
```

## Task 1: experimenting in strategy_default$control to improve ODE solver accuracy/smoothness:

1. ode_tol_rel and ode_tol_abs set @ 1*10^-0.6 --> set more/less time steps
2. schedule_eps set @ 0.001 --> set more/less cohorts
--> these vary the spacing width in the trapezium integration for the steps output - how wide (time periods or cohort size brackets) are the trapeziums we're integrating for our ODEs to get total numbers for individual's height growth etc? 
-- Control parameters that tune various aspects of the numerical solvers
--> compare lower and higher values
plot leaf area line versions with different values and same plot with the multiple lines to see how different values are changing accuracy & noise, not the "saw-toothy" sharp points/corners, need to resolve better


#my base_parameters function
```{r}
#base parameters

base_params <- function(rec_decay = 0) {
 
  p0 <- scm_base_parameters("FF16")
 
  p0$strategy_default$lma <- 0.07
  p0$strategy_default$hmat <- 15
  p0$strategy_default$rho <- 700
  p0$strategy_default$a_l1 <- 2.17
  p0$strategy_default$a_l2 <- 0.5
  
  p0$strategy_default$recruitment_decay <- rec_decay
  
  p0
}

```

#my run_patch function
```{r}

#run patch function with seed rain exponential decay and control params edited in p0

run_mypatch_edit <- function(
  traits =  trait_matrix(c(0.07), c("lma")),
  B_lf1 = 1,
  seed_rain = 20,
  p0 = base_params(),
  ctrl=scm_base_control(),
  latitude = 28.182
  ) {
  
  hyper_par_fn = make_FF16_hyperpar(B_lf1 = B_lf1, latitude = latitude)
  p1 <- expand_parameters(traits, p0, hyper_par_fn, mutant = FALSE)
  p1$seed_rain = seed_rain
  results <- build_schedule(p1, ctrl = ctrl)
  out <- run_scm_collect(results, ctrl=ctrl)

  out
}

```


#Note: what does the exponential decay function look like?

```{r}
##seed_rain*exp(-decay*time) time in years --> what does the exponential decay look like?
seed_rain_decay <- function(seedrain = 100, decay = 0, time = seq(0, 10, by=0.01)){
  tibble(
    time = time,
    seeds = seedrain*exp(-decay*time)
  )
}

seed_rain_decay(100,5) %>%
  ggplot(aes(time, seeds)) +
  geom_line() 

```


#create, tidy, expand, gather totals:

```{r}

##create patch
results_decay6 <- 
  run_mypatch_edit()

#tidy the results
results_decay_tidy <- 
  results_decay6 %>% 
  tidy_patch()

#expand state to capture additional state variables (e.g.leaf area)
results_tidy_expand <- results_decay_tidy %>% FF16_expand_state()

#integrate to calculate species totals
data_species_tot <- 
  results_tidy_expand$species %>% integrate_over_size_distribution()

```


```{r}

#plot size distribution over time
results_decay_tidy$species %>%
  drop_na() %>%
plot_size_distribution()

## plot LA over time
 data_species_tot %>%
  ggplot(aes(time, area_leaf)) +
  geom_line()
 
```


## function for all - grow patch, tidy, expand, calculate totals

```{r}

grow_tidy_expand_totals <- function(oderel=1e-4, odeabs=1e-4, scheps=0.005, rec_decay=0) {
  
  
  ctrl = scm_base_control()
  
  ctrl$ode_tol_rel <- oderel
  ctrl$ode_tol_abs <- odeabs
  ctrl$schedule_eps <- scheps

  p = base_params(rec_decay)
  patch <- run_mypatch_edit(p0 = p, ctrl = ctrl)
  patch_tidy <- tidy_patch(patch)
  patch_expand <- FF16_expand_state(patch_tidy)
  patch_totals <- integrate_over_size_distribution(patch_expand$species)
  
}


# default
allsteps <- grow_tidy_expand_totals(1e-4, 1e-4, 0.005, 0)

#higher resolution
allsteps <- grow_tidy_expand_totals(1e-5, 1e-5, 0.0001, 0)

allsteps %>%
  ggplot(aes(time, area_leaf)) +
  geom_line()

```


## varied ODE tolerance rel/abs and schedule eps & plot:
```{r}
## vary tolerance of cohort schedule

## vary schedule eps & plot LA vs time results

sch_eps_values <- c(0.01, 0.001, 0.0001) %>% map_dfr(~grow_tidy_expand_totals(scheps = .x), .id="run")

sch_eps_values %>% ggplot(aes(time, area_leaf, col=run)) + geom_line()

```



## Self-thinning -- background info
Obtaining the Self-Thinning Line from a size structured non-finite population growing through time


1. The "self-thinning line" is obtained when we plot N, the number of individuals of each size bracket per unit area (size structured density), against mean S, their mean size (e.g. via their "height"). Scaling these axes by log10 produces a straight "thinning line".

$$ N_{T}= \int_{S_{0}}^{S_{MAX}}N(S)ds.....S_{T} = \int_{S_{0}}^{S_{MAX}} S.N(S)ds.....\overline{S} = \frac{S_{T}}{N_{T}} $$
i.e. the plot shows size-density (N-S) using the above integrals to calculate N and S across the size spectrum. 

a. To get the total N, we integrate N from initial to max size to get the total number of individuals, for all steps through time. I.e. calculating the area under the curve from S_0 to S_MAX at time step 1, then the area under the curve from S_0 to S_MAX at time step 2, etc → i.e. integrating: S*N(S), the size x the # of individuals at that size: from initial to max size, and mean size is just the total quantity of size e.g. combined heights / number at that height (N(T))

b. For total S, we integrate 

c. We need the mean size $\overline S$ for our self-thinning line, which we can get by dividing the combined size by total density at each step

2a. We cannot simply use the "density" output from plant, which represents the cohorts or the expected/average individual trajectories of specific size/age classes with varying numbers over time. We must use the size/age data of all individual plants for the self-thinning dynamic to be observed. The integration must be weighted by the number of individuals in each size/age class. With cohorts we are just using a representative individual without the details of how many individuals each may represent, the cohort-density with size. For example if we took 100 cohorts that each represent a different approximate age/size, each representing numbers from close to zero to numerous individuals, but we simply divided the total height by 100 rather than the number those 100 cohort "groups" represent, we essentially lose all the important individual density data.

b. Just using cohorts would look something like:
patch01 <- run_mulga_patch() %>% tidy_patch()
height_density <-
  patch01$species %>%
  group_by(step) %>%
  summarise_at(vars(height, density), list(mean = mean), na.rm = TRUE)

   ggplot(height_density, aes(x = height_mean, y = density_mean)) + 
     geom_line() +
    labs(x = "Mean Height (m)",
         y = "Mean Density (per unit area)",
         title = "Size-Density stepped through time") +
     scale_x_log10() +
     scale_y_log10()

Mathematically, this is equivalent to the integral and approximate summation: 

$$N(t)=\int_0^\infty n(H,t)dH \simeq \sum_i n(H_{i},t)(H_{i}-H_{i-1}) = \sum_i^K \frac{n(H_{i},t)}{K}$$
where K is the sum off all height classes. This method sums up all cohorts of all size/age classes at each time step and calculates the mean of their summed heights. 

3a. We improve our approximation by integrating across the regions under the size-density curve we are interested in, accounting for the number of individuals and their mean height for each separate size class. In doing so, we are able to account for the continual influx of saplings which would otherwise skew our mean height and density data, and thus focus on the larger individuals that are growing into maturity. This can be done with the following integral and its approximate sum:

$$ \overline{H}=\int_0^\infty \frac{ Hn(H,t)}{N(t)}dt \simeq \frac{\sum H_{i}n(H_{i},t)(H_{i}-H_{i-1})}{\sum n(H_{i},t)(H_{i}-H_{i-1})} = \frac{\sum H_{i}}{K}$$

b. However, we must recognise that not all our subintervals of integration will be equal in size/width, as the time steps in the initial stand phase are much shorter to account for the extremely dynamic nature of this period and to capture all of this detail. We cannot take K to be a sum of equal (Hi - (Hi-1)) segments. And the regular introduction of new individuals at different times means that we need to determine the density per height segment (Hi-(Hi-1)) per unit area, #/H/m^2

[actually no, still need to account for weighted density] In an even-aged population where all trees are approximately the same age and growing at close to the same rate, and there are a finite number of individuals in the stand, this method might produce a reasonable approximation of the thinning line. 

c. Trapazoidal Rule in R → The Trapezoidal Rule is one of Closed Newton-Cotes formulas for approximating the definite integral of a function. We integrate by calculating and summing the areas of many consecutive trapezoids below our size-density curve, which gives a good approximation of the population dynamics in this case.

d. Additionally, we may need to select a cut-off point in the stand's age at which we stop incorporating new individuals into the model, as these new saplings likely pop up (when older larger plants die during the thinning process providing short periods of increased light and space?), but these saplings don't persist to compete with the main/mature stand. + minimum height to further reduce noise?


##################   ##################   ##################   ##################   ##################
4. see: emergent.Rmd -> using plant to investigate patch dynamics focusing on emergent patch-level features arising from collective individual-level interactions. 

a. Each line shows what the size-density profile looks like for a specific time step, with the 5-year, 10-year, 20-year, 40-year and 105-year profiles highlighted in blue. In the 5-year profile, the density for the majority, middle chunk of heights, is low due to self-thinning, with the numbers going back up for the tallest individuals (strongest competitors, around 4-5m tall). The 10-year profile shows a similar shape, with a wider, deeper dip down in numbers for the middle range of heights, and higher density for the taller, canopy forming survivors ~7-8m tall. In the 20-year profile you can see that a pulse in recruitment occurs with a higher density of trees around 4m, before the recurrent dip and return to high density especially of around 12-13.5m individuals. The pulse continues to grow, visible in the 40-year profile, with reasonable densities until the steep drop just before 15m, then increase at canopy height. By 105 years the stand is very old and at a stable age distribution, with a very thin gap in density just below the canopy.

b.Where is the leaf area in the patch coming from; a profile of leaf area with respect to height.

c.Finally, we can see where height growth rate is concentrated in the population.  This differs from the profile in the [Individuals vignette] (https://traitecoevo.github.io/plant/articles/individuals.html)
because it is reduced depending on the light environment, but that environment is the one constructed by the individual itself.

d. Integration over a metapopulation: 
The above plots show relationships with patches of a given age. What about the average relationship across the entire metapopulation? To get that, we  average (integrate) over the distribution over patch
(for formula see demography vignette). To achieve this we first need the patch-level relationships to a series of fixed heights. We'll use a spline interpolation, on log-log-scaled data, clamped so that for x values outside the observed range are set to zero. Now interpolate the height-density relationship in each patch to the series of specified heights. For each of these heights, we can now integrate across patches (i.e. across rows), weighting by patch abundance. Average the red line in the plot (red line).

examples TRAPEZIUM RULE:

[see emergent.Rmd]
trapezium <- plant:::trapezium
n_av <- apply(n_hh, 1,
              function(x) trapezium(result$time, x * result$patch_density))
[see patch.Rmd]
metapopulation <- function(x){
  plant:::trapezium(t2, x*result_2sp$patch_density)
}

[see tidy_patch.R]
totals <- results2$species %>%
    select(-cohort) %>% na.omit() %>% 
    filter(step > 1) %>% 
    group_by(step, time, patch_density, species) %>% 
    summarise(
      individuals = -plant:::trapezium(height, density),
      across(c(starts_with("area"), starts_with("mass"), starts_with("mortality"), starts_with("height")), ~ -plant:::trapezium(height, density*.x)),#, .names = "{.col}_tot"),
      .groups="drop"
      )
##################   ##################   ##################   ##################   ##################


i. Calculate total amounts of height
ii. group_by step, time, patch_density, species
iii. summarise - plant:::trapezium(height,density---integrating across density (# individuals on y-axis)). density*.x each time step's distribution of height-densities, then divide by total number , integrate total height then divide by total number individuals. then divide average size for individuals
iv. only use early successional individuals, not later cohorts, filter out, calculate integrals, or patch total should have minimum height to discount new saplings coming in?
v. at each time point, filter to get a density estimate at that point and add into the calculation