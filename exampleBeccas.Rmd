---
title: "self-thinning edits"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# installation
Using a version off a branch

```{r, eval=FALSE}
remotes::install_github("traitecoevo/plant@ff16r")
```


```{r load libraries}
library(plant)
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
```

Activate logger

```{r}
plant_log_console()
```


## Errors in: 1. expand_state, 2. area_leaf not found and min_h instead of height in data_species_tot?

```{r}
run_mypatch_edit <- function(
  traits =  trait_matrix(c(0.07), c("lma")),
  p0 = scm_base_parameters("FF16", "FF16_Env"),
  find_equilbrium = FALSE
  ) {
  
  p1 <- expand_parameters(traits, p0, mutant = FALSE)
  results <- build_schedule(p1)
  out <- run_scm_collect(results)
}

results_decay <- 
  run_mypatch_edit()

results_decay_tidy <- 
  results_decay %>% 
  tidy_patch()

## expand_state error
results_tidy_expand <- results_decay_tidy %>% expand_state()

data_species_tot <- 
  results_decay_tidy$species %>% patch_species_total()

## area_leaf not found & min_h ?
data_species_tot %>%
  ggplot(aes(time, area_leaf)) +
  geom_line()

```






in results_tidy$p0$strategy_default$control, experimenting with:

ode_tol_rel and ode_tol_abs ^-0.6
schedule_eps 0.001 
--> these vary the spacing width in the trapezium integration for the steps output - how wide (time periods) are the trapeziums we're integrating for our ODEs to get total numbers for individual's height growth etc? 

-- what do above values represent...

compare lower and higher values
plot leaf area line versions with different values and same plot with the multiple lines to see how different values are changing stuff not the "saw-tooth" sharp points, resolve better


```{r}

## need to change control parameter values and exponential decay seed rain
## Control parameters that tune various aspects of the numerical solvers --> Control(..., values = list(...)) can I change these a simpler way besides specifying as arguments to vary?? Put in run_mypatch_edit?
## scm_base_params has lower accuracy + more noisy? p0 <- FF16_Parameters() ?? 

#Also FF16 vs FF16r?? Specify FF16_env or no?? Default env?
 
#Also - seed rain decay value - if too high this affects the height/density trajectory of the initial wave of individuals, what does the exponential decay function look like, how to set value that only affects cohorts after initial wave has emerged?

base_params <- function(oderel = 1e-6, odeabs=1e-6, scheps = 0.001, rec_decay = 0) {
 
  p0 <- scm_base_parameters("FF16")
 
  p0$strategy_default$lma <- 0.07
  p0$strategy_default$hmat <- 15
  p0$strategy_default$rho <- 700
  p0$strategy_default$a_l1 <- 2.17
  p0$strategy_default$a_l2 <- 0.5
  
  p0$strategy_default$recruitment_decay <- rec_decay
  
  p0$strategy_default$control$ode_tol_rel <- oderel
  p0$strategy_default$control$ode_tol_abs <- odeabs
  p0$strategy_default$control$schedule_eps <- scheps
  
  p0
}

```

```{r}

#run patch with seed rain exponential decay -- make a minimalist working example -- remove uneccesary stuff so recreates the error, can separate out from everything else, isolate problem and fix
run_mypatch_edit <- function(
  traits =  trait_matrix(c(0.07), c("lma")),
  B_lf1 = 1,
  seed_rain = 20,
  p0 = base_params(),
  find_equilbrium = FALSE,
  latitude = 28.182
  ) {
  
  hyper_par_fn = make_FF16_hyperpar(B_lf1 = B_lf1, latitude = latitude)
  p1 <- expand_parameters(traits, p0, hyper_par_fn, mutant = FALSE)
  p1$seed_rain = seed_rain
  results <- build_schedule(p1)
  out <- run_scm_collect(results)

}

```


```{r}
##seed_rain * exp(-decay*time) time in years

##create patch
results_decay <- 
  run_mypatch_edit(traits=trait_matrix(c(0.07), c("lma")), p0 = base_params(1e-7, 1e-7, 0.005, 5))

#tidy the results
results_decay_tidy <- 
  results_decay %>% 
  tidy_patch()

#expand state to capture additional state variables (e.g.leaf area)
results_tidy_expand <- results_decay_tidy %>% expand_state()

#integrate to calculate species totals
data_species_tot <- 
  results_decay_tidy$species %>% patch_species_total()

```


```{r}

#plot size distribution over time
results_decay_tidy$species %>%
  drop_na() %>%
plot_size_distribution_patch()

## plot LA over time -- why no change with ode_tol_rel/abs & schedule_eps ?
 data_species_tot %>%
  ggplot(aes(time, area_leaf)) +
  geom_line()
 
```



## Classic Self thinnning plot

For this we need average size over time. Get average size by dividing total by the sum of individuals per unit area

Note this plot has some noise in it. Suggests integration in previous step may need more resolution, or a better method. 

Note, get cleaner results if use first cohorts

```{r}
results_tidy_expand$species %>% filter(cohort < 150) %>% 
  patch_species_total() %>%
  mutate(
    area_stem_av = area_stem / individuals,
    # A = pi*D^2/4 -> D = 
    diam_stem_av = sqrt(area_stem_av)
    ) %>% 
  ggplot(aes(area_stem_av, individuals, colour=species)) +
  geom_line() +
  scale_y_log10() +
  scale_x_log10() +
  theme_classic()
```


Note bottom density fluctuates over time, this makes sense if germination is responding to leaf area above

Possibility this is error in calculating competition -- i.e. total leaf area?

How is integral achieved in plant?

```{r}
results_tidy_expand$species %>% 
  drop_na() %>%
  group_by(step, species, time) %>%
  slice_tail() %>% 
  ungroup() %>%
  ggplot(aes(time, density)) + geom_line()
```

# Work in progress why is there noise in the self thinning relationship

```{r}
results_tidy_expand$species %>% 
  patch_species_total() %>%
  mutate(
    area_stem_av = area_stem / individuals,
    diam_av = 
    ) %>% 
  ggplot(aes(area_stem_av, individuals, colour=species)) +
  geom_line() +
  scale_y_log10() +
  scale_x_log10() +
  theme_classic()

  
results_tidy_expand$species %>% filter(height > 1, time> 20, time<50) %>% 
  patch_species_total() %>%
  mutate(area_stem_av = area_stem / individuals) %>% 
  ggplot(aes(area_stem_av, individuals, colour=species)) +
  geom_line() +
  scale_y_log10() +
  scale_x_log10() + 
  theme_classic()

results_tidy_expand$species %>% filter(height > 0, time> 0, time<150) %>% 
  patch_species_total() %>%
  ggplot(aes(time, individuals, colour=species)) +
  geom_line() + 
  theme_classic()

results_tidy_expand$species %>% filter(step%in% c(138, 139, 140, 141)) %>% 
  select(step, height, density) %>%
  arrange(step,height) %>%
  group_by(step) %>%
  mutate(
    dx = lead(height) -height,
    y = 0.5*(density + lead(density)),
    xy = dx*y
  ) %>% ungroup() -> tmp

tmp %>% filter(step==138) %>% pull(xy) %>% sum(na.rm=TRUE)

data_species_tot%>% filter(species==1, step==138)

ggplot(tmp %>% filter(height > 0.5), aes(height, y, group=step, col=as.character(step))) + geom_point() + geom_line() + scale_x_log10()

  
results_tidy_expand$species %>% filter(height > 0, time> 30, time<31) %>% View() 
  
results_tidy_expand$species %>%
ggplot(aes(height, density, colour=time, group=time)) +
  geom_line() +
  scale_y_log10() +
  scale_x_log10() + 
  theme_classic() + 
  facet_wrap(~species)


results_tidy_expand$species %>% filter(species==1) %>% plot_size_distribution_patch()   


```


```{r}

##
my_results_tidy_expand$species %>% filter(height > 1) %>% 
  data_species_tot %>%
  mutate(area_stem_av = area_stem / individuals) %>% 
  ggplot(aes(area_stem_av, individuals, colour=species)) +
  geom_line() +
  scale_y_log10() +
  scale_x_log10() + 
  theme_classic()

## 
p3 <- results_tidy_expand$species %>% plot_size_distribution_patch()
p4 <- data_species_tot2 %>% 
  filter(species==1) %>%
  filter()
  mutate(size_av = area_stem / individuals) %>%
  ggplot(aes(size_av, individuals, label = step)) +
  geom_line() +
  scale_x_log10() +
  scale_y_log10() + 
  theme_classic()
p3 + p4

## ggplot(aes(x= MIN, y= PTS, colour="green", label=Name))+
##   geom_point() +
##   geom_text(aes(label=ifelse(PTS>24,as.character(Name),'')),hjust=0,vjust=0)
 
## 5 
data_species_tot %>% 
  filter(height > 0.5) %>%
  ggplot(aes(time, individuals)) +
  geom_line() +
  scale_x_log10() +
  scale_y_log10() + 
  theme_classic()

```



```{r}
grow_indv_time <- function(environment=1.0, times=seq(0,50,length.out=101)) {
  
  ff16_strategy <- FF16_Strategy()
  indv_FF16 <- FF16_Individual(s = ff16_strategy)
  env <- FF16_fixed_environment(environment)
  grow_plant_results <- grow_plant_to_time(indv_FF16, times, env)
  cbind(time = grow_plant_results$time, grow_plant_results$state) %>%
    as_tibble() %>% mutate(env=environment)
}


grow_plant_results <- grow_indv_time(env=0.75)


plot_indv_time <- function(data) {
  ggplot(data, aes(x = time, y = height)) +
  geom_line() 
}


plot_indv_time(grow_plant_results)


grow_and_plot <- function(...){
  grow_plant_results <- grow_indv_time(...)
  plot_indv_time(grow_plant_results)
}



allplants <- seq(.2, 1, by=0.2) %>% map_df(~grow_indv_time(environment=.x))

allplants <- seq(.2, 1, by=0.2) %>% map_df(grow_indv_time)

allplants %>% ggplot(aes(time, height, group = env, col = env)) + geom_line()
```


## INTRO notes:: Obtaining the Self-Thinning Line from a size structured non-finite population growing through time


1. The "self-thinning line" is obtained when we plot N, the number of individuals of each size bracket per unit area (size structured density), against mean S, their mean size (e.g. via their "height"). Scaling these axes by log10 produces a straight "thinning line".

$$ N_{T}= \int_{S_{0}}^{S_{MAX}}N(S)ds.....S_{T} = \int_{S_{0}}^{S_{MAX}} S.N(S)ds.....\overline{S} = \frac{S_{T}}{N_{T}} $$
i.e. the plot shows size-density (N-S) using the above integrals to calculate N and S across the size spectrum. 

a. To get the total N, we integrate N from initial to max size to get the total number of individuals, for all steps through time. I.e. calculating the area under the curve from S_0 to S_MAX at time step 1, then the area under the curve from S_0 to S_MAX at time step 2, etc → i.e. integrating: S*N(S), the size x the # of individuals at that size: from initial to max size, and mean size is just the total quantity of size e.g. combined heights / number at that height (N(T))

b. For total S, we integrate 

c. We need the mean size $\overline S$ for our self-thinning line, which we can get by dividing the combined size by total density at each step

2a. We cannot simply use the "density" output from plant, which represents the cohorts or the expected/average individual trajectories of specific size/age classes with varying numbers over time. We must use the size/age data of all individual plants for the self-thinning dynamic to be observed. The integration must be weighted by the number of individuals in each size/age class. With cohorts we are just using a representative individual without the details of how many individuals each may represent, the cohort-density with size. For example if we took 100 cohorts that each represent a different approximate age/size, each representing numbers from close to zero to numerous individuals, but we simply divided the total height by 100 rather than the number those 100 cohort "groups" represent, we essentially lose all the important individual density data.

b. Just using cohorts would look something like:
patch01 <- run_mulga_patch() %>% tidy_patch()
height_density <-
  patch01$species %>%
  group_by(step) %>%
  summarise_at(vars(height, density), list(mean = mean), na.rm = TRUE)

   ggplot(height_density, aes(x = height_mean, y = density_mean)) + 
     geom_line() +
    labs(x = "Mean Height (m)",
         y = "Mean Density (per unit area)",
         title = "Size-Density stepped through time") +
     scale_x_log10() +
     scale_y_log10()

Mathematically, this is equivalent to the integral and approximate summation: 

$$N(t)=\int_0^\infty n(H,t)dH \simeq \sum_i n(H_{i},t)(H_{i}-H_{i-1}) = \sum_i^K \frac{n(H_{i},t)}{K}$$
where K is the sum off all height classes. This method sums up all cohorts of all size/age classes at each time step and calculates the mean of their summed heights. 

3a. We improve our approximation by integrating across the regions under the size-density curve we are interested in, accounting for the number of individuals and their mean height for each separate size class. In doing so, we are able to account for the continual influx of saplings which would otherwise skew our mean height and density data, and thus focus on the larger individuals that are growing into maturity. This can be done with the following integral and its approximate sum:

$$ \overline{H}=\int_0^\infty \frac{ Hn(H,t)}{N(t)}dt \simeq \frac{\sum H_{i}n(H_{i},t)(H_{i}-H_{i-1})}{\sum n(H_{i},t)(H_{i}-H_{i-1})} = \frac{\sum H_{i}}{K}$$

b. However, we must recognise that not all our subintervals of integration will be equal in size/width, as the time steps in the initial stand phase are much shorter to account for the extremely dynamic nature of this period and to capture all of this detail. We cannot take K to be a sum of equal (Hi - (Hi-1)) segments. And the regular introduction of new individuals at different times means that we need to determine the density per height segment (Hi-(Hi-1)) per unit area, #/H/m^2

[actually no, still need to account for weighted density] In an even-aged population where all trees are approximately the same age and growing at close to the same rate, and there are a finite number of individuals in the stand, this method might produce a reasonable approximation of the thinning line. 

c. Trapazoidal Rule in R → The Trapezoidal Rule is one of Closed Newton-Cotes formulas for approximating the definite integral of a function. We integrate by calculating and summing the areas of many consecutive trapezoids below our size-density curve, which gives a good approximation of the population dynamics in this case.

d. Additionally, we may need to select a cut-off point in the stand's age at which we stop incorporating new individuals into the model, as these new saplings likely pop up (when older larger plants die during the thinning process providing short periods of increased light and space?), but these saplings don't persist to compete with the main/mature stand. + minimum height to further reduce noise?


##################   ##################   ##################   ##################   ##################
4. see: emergent.Rmd -> using plant to investigate patch dynamics focusing on emergent patch-level features arising from collective individual-level interactions. 

a. Each line shows what the size-density profile looks like for a specific time step, with the 5-year, 10-year, 20-year, 40-year and 105-year profiles highlighted in blue. In the 5-year profile, the density for the majority, middle chunk of heights, is low due to self-thinning, with the numbers going back up for the tallest individuals (strongest competitors, around 4-5m tall). The 10-year profile shows a similar shape, with a wider, deeper dip down in numbers for the middle range of heights, and higher density for the taller, canopy forming survivors ~7-8m tall. In the 20-year profile you can see that a pulse in recruitment occurs with a higher density of trees around 4m, before the recurrent dip and return to high density especially of around 12-13.5m individuals. The pulse continues to grow, visible in the 40-year profile, with reasonable densities until the steep drop just before 15m, then increase at canopy height. By 105 years the stand is very old and at a stable age distribution, with a very thin gap in density just below the canopy.

b.Where is the leaf area in the patch coming from; a profile of leaf area with respect to height.

c.Finally, we can see where height growth rate is concentrated in the population.  This differs from the profile in the [Individuals vignette] (https://traitecoevo.github.io/plant/articles/individuals.html)
because it is reduced depending on the light environment, but that environment is the one constructed by the individual itself.

d. Integration over a metapopulation: 
The above plots show relationships with patches of a given age. What about the average relationship across the entire metapopulation? To get that, we  average (integrate) over the distribution over patch
(for formula see demography vignette). To achieve this we first need the patch-level relationships to a series of fixed heights. We'll use a spline interpolation, on log-log-scaled data, clamped so that for x values outside the observed range are set to zero. Now interpolate the height-density relationship in each patch to the series of specified heights. For each of these heights, we can now integrate across patches (i.e. across rows), weighting by patch abundance. Average the red line in the plot (red line).

examples TRAPEZIUM RULE:

[see emergent.Rmd]
trapezium <- plant:::trapezium
n_av <- apply(n_hh, 1,
              function(x) trapezium(result$time, x * result$patch_density))
[see patch.Rmd]
metapopulation <- function(x){
  plant:::trapezium(t2, x*result_2sp$patch_density)
}

[see tidy_patch.R]
totals <- results2$species %>%
    select(-cohort) %>% na.omit() %>% 
    filter(step > 1) %>% 
    group_by(step, time, patch_density, species) %>% 
    summarise(
      individuals = -plant:::trapezium(height, density),
      across(c(starts_with("area"), starts_with("mass"), starts_with("mortality"), starts_with("height")), ~ -plant:::trapezium(height, density*.x)),#, .names = "{.col}_tot"),
      .groups="drop"
      )
##################   ##################   ##################   ##################   ##################


i. Calculate total amounts of height
ii. group_by step, time, patch_density, species
iii. summarise - plant:::trapezium(height,density---integrating across density (# individuals on y-axis)). density*.x each time step's distribution of height-densities, then divide by total number , integrate total height then divide by total number individuals. then divide average size for individuals
iv. only use early successional individuals, not later cohorts, filter out, calculate integrals, or patch total should have minimum height to discount new saplings coming in?
v. at each time point, filter to get a density estimate at that point and add into the calculation


## END BECCA'S WORK 


The cohort spacing algorithm determines the optimum introduction times for characteristics, which means that the time values associated with steps may not correspond to known times that we might like to extract information about. For example, what the total amount of biomass per $m^2$ be at 50 years. By doing this, it also means that we can integrate between defined times.


```{r}
results <- run_mypatch(traits =  trait_matrix(c(0.07, 0.24), c("lma")))

results_tidy <- results %>%
  tidy_patch()

```


Lets interpolate our results from the run_mypatch above for timepoints 1,5,10, 1000. Note that time in unit years. 

```{r}
times <- c(1, 5, 10, 1000)

tidy_species_data <- results_tidy$species

tidy_species_new <- interpolate_to_times(tidy_species_data, times)

```

Gives interpolated values for state variables at new time points. 

```{r}
tidy_species_new
```

We can now assess their correspondence with the values already predicted in the original results output. We can see in this case that the points (represneting the interpolated values) fall along the curves which indicates good correspondence bewteen our interpolation and the original simulation. 

```{r}
data_combined <- 
  tidy_species_data %>%
  bind_rows(tidy_species_new) %>%
  arrange(species, cohort, time) %>% 
  filter(cohort %in% seq(1, 101, by=20))

data_combined_long <- 
  data_combined  %>% 
  select(cohort, time, step, density, height, species) %>% 
  pivot_longer(cols = c("density", "height"))

data_combined_long %>% 
  ggplot(aes(time, value, group=cohort,colour=cohort)) +
  geom_line() +
  geom_point(data = data_combined_long %>% filter(is.na(step)), col=2) +
  scale_y_log10() +
  xlim(c(0, 20)) +
  facet_grid(name~species, scales="free") +
  theme_classic()
```

## Interpolate to heights

Similar to above, can interpolate across cohorts at given time to sepcific heights

```{r}
heights <- c(1, 5, 10)

tidy_species_data <- results_tidy$species

tidy_species_new <- interpolate_to_heights(tidy_species_data, heights)
```

Gives predictions at new time points. 

```{r}
tidy_species_new %>% drop_na()
```

To see how good these are, plot together with old points

```{r}
data_combined <- 
  tidy_species_data %>%
  bind_rows(tidy_species_new) %>%
  arrange(species, time, height) %>% 
  filter(step %in% c(100, 150))

data_combined_long <- 
  data_combined  %>% 
  select(cohort, time, step, height, density, mortality, area_heartwood, species) %>% 
  pivot_longer(cols = c("density", "mortality", "area_heartwood"))

data_combined_long %>% 
    filter(!is.na(cohort)) %>% 
  ggplot() +
  geom_line(aes(height, value, group=step, colour=step)) +
  geom_point(data = data_combined_long %>% filter(is.na(cohort)), aes(x=height, y=value), col="red")+
  facet_grid(name~species, scales="free") +
  theme_classic()
```


By pulling out the 'species' object from our list of tidied result outputs, we can plot the size distribution for each of the species in the patch. In this plot, each line represents the height over time of a characteristic originating at a given height (given by seed mass) at each step. Note that steps in this case are not equivalent to years, where the distance between steps is instead determined by the cohort spacing algorithm. We can take advantage of varying line transparency in ggplot2 to plot the relative log(Density) of each characteristic the size distribution of each species in the pathc. 

## Calculate totals by species for each step

For each species, we can integrate over the height distribution to get the total value of the state variable per $m^2$

For example, the number of individuals per $m^2$ is found by integrating the density of each characteristic at a given step over height.

```{r}
data_species_tot %>% 
  ggplot(aes(time, individuals, colour=species)) +
  geom_line()
```

We can use the function 'expand_state' to capture a large number of additional state variables (e.g.leaf area)

In the same way as individuals above, we can have a look at the total leaf area over time by integrating across the size (i.e. height) distribution for a given step or time. This involves finding the product of the density of each of the characteristics present multiplied by the state variable in question (i.e. leaf area) before integrating across height. 


In this case, species 1 with cheap, thin leaves briefly has a much higher total leaf area deployed compared across the height distribution before eventually being overtaken by species with thicker, more expensive leaves. 
